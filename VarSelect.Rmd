---
title: "Variable Selection"
author: "Alex Dombowsky"
date: "4/7/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(purrr)
library(invgamma)
library(bridgesampling)
library(spBayesSurv)
library(survival)
library(xtable)
```

# Loading Data
```{r}
load("opiod.RData")
main = opiod$main
asd = opiod$ASD
asg = opiod$ASG
asm = opiod$ASM
asp = opiod$ASP
asi = opiod$ASI
dem = opiod$DEM
dsm = opiod$DSM
eom = opiod$EOM
nms = opiod$NMS
qol = opiod$QOL
qlp = opiod$QLP
fnd = opiod$FND
mhx = opiod$MHX
vis = opiod$VIS

op_list = list(main, asd, asg, asm, asp, asi, dem, dsm, eom, nms, qol, qlp, fnd, mhx, vis)
# results in 570 by 119 matrix
opiod_df <- op_list %>% reduce(full_join, by = "PATID")
opiod_df <- opiod_df[, !grepl("X.", colnames(opiod_df), fixed = T)]
opiod_df <- opiod_df[!is.na(opiod_df$event), ]


```


# AFT model

```{r}
# compute Bayes factor function
compute_bf_s <- function(L_obs, l_c, delta, R, B, f1, f2, a, b.sq) {
  
  # 1: define two models
  X1 = model.matrix(lm(f1, data = opiod_df))
  p1 = ncol(X1)
  beta_01 = rep(0, p1) # default
  Sigma_01= solve(crossprod(X1, X1)) # default
  # more complicated model
  X2 = model.matrix(lm(f2, data = opiod_df))
  p2 = ncol(X2)
  beta_02 = rep(0, p2) # default
  Sigma_02 = solve(crossprod(X2,X2)) # default
  
  # 2: compute log-posterior under both models
  log_posterior_f1<- function(pars, data){
  L_obs <- data$L_obs
  l_c <- data$l_c
  X <- data$X
  p = ncol(X)
  n = nrow(X)
  n_cens = length(l_c)
  names = c(paste("Beta", 1:p), "phi", "g")
  beta <- pars[names[1:p]]
  phi <- pars[names[p+1]]
  g <- pars[names[p+2]]
  beta_0 = beta_01
  Sigma_0 = Sigma_01
  a = a
  b = b.sq
  out <-
    sum(dlnorm(exp(L_obs), X[(n_cens + 1): n, ] %*% beta, sqrt(1/phi), log = T)) +
    sum(pnorm(phi * (l_c - X[1:n_cens, ] %*% beta), log.p = T))
    dmvnorm(beta, beta_0, Sigma_0 * g/phi, log = TRUE) +  # beta prior
    dgamma(phi, a/2, a * b^2/2, log = TRUE) + # phi prior
    dinvgamma(g, 1/2, n/2, log = TRUE) # g prior
  return(out)
  }
  
  log_posterior_f2<- function(pars, data){
  L_obs <- data$L_obs
  l_c <- data$l_c
  X <- data$X
  p = ncol(X)
  n = nrow(X)
  n_cens = length(l_c)
  names = c(paste("Beta", 1:p), "phi", "g")
  beta <- pars[names[1:p]]
  phi <- pars[names[p+1]]
  g <- pars[names[p+2]]
  beta_0 = beta_02
  Sigma_0 = Sigma_02
  a = a
  b = b.sq
  out <-
    sum(dlnorm(exp(L_obs), X[(n_cens + 1): n, ] %*% beta, sqrt(1/phi), log = T)) +
    sum(pnorm(phi * (l_c - X[1:n_cens, ] %*% beta), log.p = T))
    dmvnorm(beta, beta_0, Sigma_0 * g/phi, log = TRUE) +  # beta prior
    dgamma(phi, a/2, a * b^2/2, log = TRUE) + # phi prior
    dinvgamma(g, 1/2, n/2, log = TRUE) # g prior
  return(out)
  }
  
  # getting samples
  samp1 <- relapse_gibbs(R, B, L_obs, delta, l_c, p1, X1, beta_01, Sigma_01, a, b.sq)
  samp_mcmc1 = cbind(samp1$beta, samp1$phi, samp1$g)
  samp2 <- relapse_gibbs(R, B, L_obs, delta, l_c, p2, X2, beta_02, Sigma_02, a, b.sq)
  samp_mcmc2 = cbind(samp2$beta, samp2$phi, samp2$g)

  # names and lower bounds
  names1 = c(paste("Beta", 1:p1), "phi", "g")
  lb1 = c(rep(-Inf, p1), 10^-20, 10^-20)
  ub1 = c(rep(Inf, p1), Inf, Inf)
  names(lb1) = names(ub1) = colnames(samp_mcmc1) = names1

  names2 = c(paste("Beta", 1:p2), "phi", "g")
  lb2 = c(rep(-Inf, p2), 10^-20, 10^-20)
  ub2 = c(rep(Inf, p2), Inf, Inf)
  names(lb2) = names(ub2) = colnames(samp_mcmc2) = names2

  # computing Bayes factor
  bridge1 = bridge_sampler(samples = samp_mcmc1,
                        log_posterior = log_posterior_f1,
                        data = list(L_obs = L_obs, l_c = l_c, X = X1),
                        lb = lb1,
                        ub = ub1, silent=TRUE)

  bridge2 = bridge_sampler(samples = samp_mcmc2,
                        log_posterior = log_posterior_f2,
                        data = list(L_obs = L_obs, l_c = l_c, X = X2),
                        lb = lb2,
                        ub = ub2, silent = TRUE)

  result = bayes_factor(bridge2, bridge1, log = TRUE)
  pr = post_prob(bridge1, bridge2)
  pr = as.vector(pr)
  names(pr) = c()
  result = c(result$bf,  pr[1], pr[2])
  return(result)
}


```

```{r}
# testing variable selection
opiod_df <- with(opiod_df, opiod_df[order(event),])
opiod_df <- opiod_df[!is.na(opiod_df$event), ]
R = 10000
B = 2000
L_obs = log(opiod_df$time[opiod_df$event == 1])
l_c = log(opiod_df$time[opiod_df$event==0])
delta = opiod_df$event
a = 2
b.sq = 1

f1 = formula(lm(time ~ TRTSHOWN, data = opiod_df))
f2 = formula(lm(time ~ TRTSHOWN + VIWTLBS, data = opiod_df))


compute_bf_s(L_obs, l_c, delta, R, B, f1, f2, a, b.sq)
```
Cox Proportional Hazards Model:

```{r}
# fitting a model
mcmc=list(nburn=2000, nsave=8000, nskip=0, ndisplay=1000)
prior = list()
f = Surv(time, event) ~ TRTSHOWN + I(MHOPIWDL > 5) + NMRXMED + factor(QLANXDEP) + ASBRTHDT + AMCHRMPR + DEGENDER + FNSMOKE + NMRDTX

# variable selection
vsel <- survregbayes(formula = f,
                     data = opiod_df,
                     mcmc = mcmc,
                     survmodel = "PH",
                     selection = T)
sink(file='myoutput_backup.txt')
summary(vsel)
sink()

# model with highest probability: TRTSHOWN,I(MHOPIWDL > 5),adverse,I(ADOPI30D > 0)
# getting rid of VIBMI after its CI crosses 0

# interactions

f = Surv(time, event) ~ (TRTSHOWN + I(MHOPIWDL > 5))^2

vsel_is <- survregbayes(formula = f,
                     data = opiod_df,
                     mcmc = mcmc,
                     survmodel = "PH",
                     selection = T)

sink(file='myoutput_interactions.txt')
summary(vsel_is)
sink()

# best model: TRTSHOWNXR-NTX

f = Surv(time, event) ~ TRTSHOWN + I(MHOPIWDL > 5)

cph_fit <- indeptCoxph(f,
                       data = opiod_df, 
                       prior = list(S0 = 2.5^2 * diag(1, 2)),
                       mcmc = mcmc)

sink(file='cph_output.txt')
summary(cph_fit)
sink()

# fitting the same model to the AFT and comparing DIC/WAIC
aft <- survregbayes(formula = f,
                     data = opiod_df,
                     survmodel = "AFT",
                    prior = list(S0 = 2.5^2 * diag(1, 2)),
                      mcmc = mcmc)
summary(aft)
cph <- survregbayes(f,
                       data = opiod_df,
                       survmodel = "PH",
                    prior = list(S0 = 2.5^2 * diag(1, 2)),
                       mcmc = mcmc)
summary(cph)

DIC <- c(3737.309, 3752.968)
WAIC <- c(3736.435, 3752.556)
model <- c("CPH", "AFT")
df <- data.frame(model = model, WAIC = WAIC, DIC = DIC)
print(xtable(df))

summ = summary(cph_fit)
df = summ$coeff
df = df[, -3]
print(xtable(df))

```

# Induction Logistic/Probit Regression
```{r}
f = inducted ~ TRTSHOWN + I(MHOPIWDL > 5) + NMRXMED + factor(QLANXDEP) + VIBMI + ASBRTHDT + AMCHRMPR + DEGENDER + FNSMOKE + AMHOSPTM + DSOPICRA + NMRDTX + NMWORKIN + QLHMLESS

options(mc.cores = 2)
ind_fit <- stan_glm(f, 
                    prior = cauchy(0, 2.5),
                    prior_intercept = cauchy(0,10),
                    iter = 10000,
                    chains = 2,
                    family = "binomial",
                    data = ind_failure)
bf <- bayesfactor_parameters(ind_fit, null = 0)
bf

# BF shows that TRTSHOWN and I(ADOPI30D > 0) are important
options(mc.cores = 2)
fit_inducted <- stan_glm(inducted ~ (TRTSHOWN + NMRDTX)^2, 
                    prior = cauchy(0, 2.5),
                    prior_intercept = cauchy(0,10),
                    iter = 10000,
                    chains = 2,
                    family = "binomial",
                    data = ind_failure)
preds = posterior_predict(fit_inducted, data = ind_failure)
cis = posterior_interval(fit_inducted, prob = .95)
fit = as.matrix(fit_inducted)
medias = apply(fit, 2, quantile, prob = 0.5)
means = colMeans(fit)
df = data.frame(means = means, medians = medias, cis)
colnames(df) = c("Mean", "Median", "2.5%", "97.5%")
print(xtable(df))


# sensitivity
preds = posterior_predict(fit_inducted, data = ind_failure)
sens = t(apply(preds, 1, function(x, c) x * c, c = ind_failure$inducted))
true_pos = rowSums(sens)
neg <- t(apply(1-preds, 1, function(x, c) x * c, c = ind_failure$inducted))
true_neg = rowSums(neg)
sensitivity = true_pos/(true_pos + true_neg)
mean(sensitivity)
hist(sensitivity)
quantile(sensitivity, probs = c(.025, 0.975))

# Goodness of fit
m = rowMeans(preds)
hist(m)


ggplot(ind_failure, aes(x = factor(event), y = ASBRTHDT)) + geom_boxplot()
table(data.frame(inducted = ind_failure$inducted, treatment = ind_failure$TRTSHOWN))
```

# Per Protocol

```{r}
# fitting a model
mcmc=list(nburn=2000, nsave=8000, nskip=0, ndisplay=1000)
prior = list()
f = Surv(time, event) ~ TRTSHOWN + I(MHOPIWDL > 5) + NMRXMED + factor(QLANXDEP) + ASBRTHDT + AMCHRMPR + DEGENDER + FNSMOKE + NMRDTX

# variable selection
pp_vsel <- survregbayes(formula = f,
                     data = pp,
                     mcmc = mcmc,
                     survmodel = "PH",
                     selection = T)
sink(file='pp_vsel.txt')
summary(pp_vsel)
sink()

f = Surv(time, event) ~ TRTSHOWN + I(MHOPIWDL > 5)
# Largest probability model as ASBRTHDT
pp_fit <- indeptCoxph(f,
                       data = opiod_df, 
                       prior = list(S0 = 2.5^2 * diag(1, 2)),
                       mcmc = mcmc)
summary(pp_fit)

summ = summary(pp_fit)
df = summ$coeff
df = df[, -3]
print(xtable(df))
```

